#!/bin/bash

# derived classes
# operators
# and so on

if [[ $# != 1 ]]
then
  printf "eror got %d arguments when expecting just one\n" "$#" >&2
  exit 1
fi

class_name="$1"
header="${class_name}.hpp"
cpp_file="${class_name}.cpp"

# very important
if [[ -f "${header}" || -f "${cpp_file}" ]]
then
  printf "error: existing implimention\n"  >&2
fi

create_header_file()
{
  touch "${header}"
  # add guards
  printf "#ifndef ${class_name^^}_HPP\n#define ${class_name^^}_HPP" >> "${header}"
}

create_class_file()
{
  touch "${cpp_file}"
  printf "#include \"${class_name}.hpp\"\n" >> "${cpp_file}"
}

add_class_definition()
{
  printf "\n#include <iostream>\n
class ${class_name}
{
  public:
    ${class_name}(void);
    ${class_name}(const ${class_name}& other);
    ${class_name}& operator=(const ${class_name}& other);
    ~${class_name}(void);
};\n\n#endif" >> "${header}"
}

add_class_member_functions()
{
  printf "#include <iostream>\n
${class_name}::${class_name}(void)
{
  std::cout << \"${class_name} default constructor called\\\n\";
}

${class_name}::${class_name}(const ${class_name}& other)
{
  std::cout << \"${class_name} copy constructor called\\\n\";
}

${class_name}& ${class_name}::operator=(const ${class_name}& other)
{
  std::cout << \"${class_name} copy assigment operator called\\\n\";
  return (*this);
}

${class_name}::~${class_name}(void)
{
  std::cout << \"${class_name} destroctor called\\\n\";
}
" >> "${cpp_file}"
}

create_header_file
add_class_definition
create_class_file
add_class_member_functions
